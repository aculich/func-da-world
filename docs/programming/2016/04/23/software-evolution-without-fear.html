<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Software Evolution Without Fear | Func Da World</title>
  <meta name="description" content="The software we create needs to evolve continuously. Let's find ways of reducing the fear in changing our code.">

  <link rel="icon" type="image/png" href="/blog-test/assets/icon.png">

  <link rel="stylesheet" href="/blog-test/css/main.css">
  <link rel="stylesheet" media="print" href="/blog-test/css/print.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Cabin:400,400i|Inconsolata|Montserrat:700">

  <link rel="canonical" href="https://owickstrom.github.io/blog-test/programming/2016/04/23/software-evolution-without-fear.html">
  <link rel="alternate" type="application/rss+xml" title="Func Da World" href="https://owickstrom.github.io/blog-test/feed.xml">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:creator" content="owickstrom">
  
  <meta name="twitter:title" content="Software Evolution Without Fear">
  
  
  <meta name="twitter:url" content="https://owickstrom.github.io/programming/2016/04/23/software-evolution-without-fear.html">
  
  
  <meta name="twitter:description" content="Oskar Wickström on functional programming.
">
  
  <meta name="twitter:image:src" content="https://owickstrom.github.io/assets/square.png">
</head>


  <body>

    <nav class="top-nav">
  <div class="wrapper">
    <a href="/blog-test/" class="home">
      <img src="/blog-test/assets/logo.png"
          srcset="/blog-test/assets/logo.png 1x,
          /blog-test/assets/logo@2x.png 2x"
          alt="FUNC DA WORLD">
    </a>
    <div class="nav">
      <ul>
        
  
  

  <li class="first  ">
    <a class="" href="/blog-test/archive.html">Archive</a>
  </li>

  
  

  <li class="  last">
    <a class="" href="/blog-test/about.html">About</a>
  </li>


      </ul>
    </div>
  </div>
</nav>


<div class="page-content">
  <div class="wrapper">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

      <header class="page-header post-header">
        <h1 class="page-title post-title" itemprop="name headline">Software Evolution Without Fear</h1>
        <p class="post-meta">
          <time datetime="2016-04-23T17:00:00+02:00" itemprop="datePublished">April 23, 2016</time> by <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Oskar Wickström</span></span>
          
          
          <span class="category">
          In <a href="/programming">programming</a>
          </span>
          
        </p>
      </header>

      <div class="post-content" itemprop="articleBody">
        <p>The software we create needs to evolve continuously. There are many reasons for programs to evolve; changing business needs, bug fixes, shifting technical requirements, performance, staff changes, quality improvements, the release of the next big Javascript framework, etc. The list goes on and on.</p>
<p>In this post I offer my rather technical viewpoint on the subject — what programming languages and tools can do to help us evolve software in a reliable way, avoiding status quo or costly rewrites. I discuss dynamic and static typing in different languages and how Haskell enables me to do large changes to the Oden compiler without introducing programming errors.</p>
<h2 id="scenario-changing-business-needs">Scenario: Changing Business Needs</h2>
<p>Let's say your job is to add a new shipping option in an E-commerce application. The existing shipping code resides in the dreaded <code>ECommerceControllerBaseFactory</code> class, weighing in at 7500+ lines of code. Everyone in the team knows how complex this code is and still it continues to thrive.</p>
<p>Eventually you find the four-level nested <code>if</code> statement doing lots of stuff with shipping options, customer bonus points, country tax regulations, mixed with all kinds of non-business concerns like logging, constructing and destructuring of values and closing resources. There's small attempts at abstraction in there, with private class methods small chunks of the work, but it's still a big <a href="https://en.wiktionary.org/wiki/complect">complected</a> mess of different capabilities and technical necessities. If you've been in the &quot;bread and butter&quot; side of systems development, I bet you've seen something like this before, both in back and front end applications.</p>
<h3 id="fear-of-change">Fear of Change</h3>
<p>Why hasn't anyone refactored this mass of complexity? Having the giant elefant in the room cannot possibly be a good thing, especially not in the part of the code that models your core business. This is where you should have the best code! I believe it usually starts out rather innocent. As the software evolves over time, by people making many small changes, complexity steadily creeps in. One additional <code>else if { ... }</code> cannot be that bad, right? Or one more nested callback, surely we can live that?</p>
<p>From my experience these growing pieces of code doesn't get refactored out of the fear of introducing bugs. Invalid business logic, null pointer exceptions, various simple programming errors, concurrency bugs — a lot of things can go wrong if you try to break this class into pieces and so we take the path of least resistance.</p>
<p>It's just not about the lines of code and complexity. As a project evolve developers usually come and go. People quit their jobs or start working in other departments or roles, and new people join. And if the project grows it it might get more developers working in parallel in the same code. Even if you had the guts to make a big change to the massive class, you could spend weeks with merge conflicts and thus have an even greater risk of errors. Also, as the fragmentation of developers increase the individual developer might now feel responsible for taking greater action.</p>
<p>When we continually opt for the change of least risk the situation does not improve. We are often pushed by deadlines or sprints, limiting our time to add, delete or modify the code in question. <em>&quot;You only need to add the shipping option, that's it! We don't have time for tests or refactoring right now&quot;</em>, you might be told.</p>
<p>One of way of dealing with these issues is to have a dedicated time slot for quality improvements. While this is probably better than doing nothing at all, working proactively with quality rather than retroactively is the way to go.</p>
<h2 id="tools-that-reduce-fear">Tools that Reduce Fear</h2>
<p>Different programming languages and tools help us at varying degrees. You can argue that a dynamically typed programming language is faster to prototype and experiment with than statically typed alternatives. As much as I love hanging out in a Scheme REPL for a couple of hours, trying stuff out and working my way forward, that itching fear or changing existing code takes hold of me when a project starts to grow.</p>
<p>There are tools for dynamically typed languages that aims to address these issues. Racket has <a href="https://docs.racket-lang.org/ts-guide/">Typed Racket</a>, a statically typed dialect of Racket. Clojure has <a href="http://typedclojure.org/">Typed Clojure</a>, an optional type system for Clojure that can validate your program at compile time. <a href="https://github.com/plumatic/schema">Schema</a> is another option for Clojure that performs runtime data validation based on contracts.</p>
<h3 id="the-haskell-experience">The Haskell Experience</h3>
<p>Programming in Haskell is another workflow for me. I personally don't rely much on the GHCi REPL for experimentation. Instead the types guide me to the end goal. That sounds cheesy, I know, but let me try to explain.</p>
<p>First off, <em>I think about it</em>. In the shower, before falling asleep, when looking out the window, when riding the bike to work. Staring at code or pressing keyboard buttons will not help me solve the problem at hand, I just get stuck and become frustrated.</p>
<p>After thinking about it, I hopefully arrive at something that might work. I start by modeling my thinking in terms of data types and function type signatures. Functions are <code>undefined</code> until I'm ready write the implementation. This is basically a top-down approach for materializing the design I have in my head into code. It enables me to explore freely and also give me statically typed code right from the start.</p>
<p>In an existing Haskell code base, given that everything is not typed as <code>IO ()</code>, making structural changes is not that scary. Having rewritten the Oden compiler from Racket to Haskell I think comparing the two implementations is reasonable. Lately I have been doing big changes to the core model of the compiler, changing thousands of lines of code affecting the majority of source files, and still I'm confident there will be no annoying programming errors, null pointer exceptions or incorrectly interleaved effects. I actively avoided making those kinds of changes to the Racket code base due to the risks of introducing runtime errors.</p>
<p>I should point out that the Oden compiler is like a big pure function with no external state, so it is easier to test than a system with integrations and side effects. And yes, I can still introduce bugs that Haskell won't be able to catch, but the majority of errors I would have to consider in a language like Java or Scheme just isn't there.</p>
<h2 id="lets-be-explicit">Let's Be Explicit</h2>
<p>Lately I've been trying to become aware of how I think about functions and data as I write programs. What I've found is that I generally think in terms of algebraic data types, records with known sets of fields, monads and functors, regardless if I'm programming in Haskell, Scheme or Javascript. <em>&quot;Oh, that's just like the List monad.&quot;</em>, I might think to myself. I consider this <em>my inner type system</em> that I fall back to when there is no explicit type system in the programming language. I suspect many of us think about code in a similar way. If so, why not formalize that into an encoding that we can share between humans and computers to improve quality? This is what I consider the essence of static typing.</p>
<p>I am certain that we can have have mainstream programming languages with static typing and still retain the expressiveness and exploratory power of dynamically typed languages. I think we should strive for tools that help us fearlessly evolve software. We can do a lot better than we are doing right now! Also, static typing as we know it today might only be a stepping stone to something even greater.</p>

      </div>

      <a id="post-comments-link"
         href="#disqus_thread"
         data-disqus-identifier="software-evolution-without-fear">
      </a>
      <noscript class="no-javascript">Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments</a>.</noscript>
    </article>
  </div>
</div>

<div class="page-comments hidden" id="post-comments">
  <div class="wrapper">
    <div id="disqus_thread"></div>
    <script src="/blog-test/js/comments.js"></script>
    <script>
    initializeComments('https://owickstrom.github.io/programming/2016/04/23/software-evolution-without-fear.html', 'software-evolution-without-fear');
    </script>
    <script id="dsq-count-scr" src="//owickstrom.disqus.com/count.js" async></script>
  </div>
</div>

<footer class="site-footer">

  <div class="wrapper">
    <p><a class="rss-subscribe" href="/blog-test/feed.xml">Subscribe via RSS</a></p>
    <p class="copyright">Copyright &copy; 2015 Oskar Wickström</p>
  </div>

</footer>



    <script>
function loadCssAsync(path) {
  function cb() {
    var l = document.createElement('link'); l.rel = 'stylesheet';
    l.href = path;
    var h = document.getElementsByTagName('head')[0]; h.appendChild(l, h);
  };
  var raf = requestAnimationFrame || mozRequestAnimationFrame ||
  webkitRequestAnimationFrame || msRequestAnimationFrame;
  if (raf) raf(cb);
  else window.addEventListener('load', cb);
};

loadCssAsync('/blog-test/css/syntax-highlighting.css');
</script>

    <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-42197774-2', 'auto');
ga('send', 'pageview');
</script>


  </body>

</html>
